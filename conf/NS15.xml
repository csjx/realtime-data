<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE instrument SYSTEM "instrument.xsd">
<instrument>
    <!-- The instrument identifier -->
    <identifier>NS15</identifier>
    <!-- The connection type: socket, file, or serial -->
    <connectionType>socket</connectionType>
    <!-- 
      Configure connection parameters based on connection type. If connection
      type is socket, add hostName and hostPort below. If file, add filePath
      below. If serial, add serialPortParams and sub elements below.
    -->
    <connectionParams> 
        <hostName>127.0.0.1</hostName>
        <hostPort>5111</hostPort>
        <!-- OR
        <filePath>
            /data/spool/NS15.log
        </filePath> -->
        <!-- OR (not implemented yet)
        <serialPort>/dev/ttyUSB0</serialPort>
        <serialPortParams>
            <baudRate>9600</baudRate>
            <dataBits>8</dataBits>
            <stopBits>1</stopBits>
            <parity>NONE</parity>
        </serialPortParams> -->         
    </connectionParams>
    <!-- The name of the instrument source as it appears in the DataTurbine -->
    <rbnbName>NS15</rbnbName>
    <!-- The IP or host name of the DataTurbine server -->
    <rbnbServer>127.0.0.1</rbnbServer>
    <!-- The port number of the DataTurbine server -->
    <rbnbPort>33333</rbnbPort>
    <!-- The number of in-memory bytes to request for this instrument source -->
    <archiveMemory>126000</archiveMemory>
    <!-- The number of on-disk bytes to request for this instrument source -->
    <archiveSize>31536000</archiveSize>
    <!-- The list of data channels to be created in the DataTurbine for this instrument source -->
    <channels>
        <!-- The default channel details. This will push ASCII data into the DataTurbine -->
        <channel default="true">
            <!-- The name of the channel -->
            <name>DecimalASCIISampleData</name>
            <!-- The channel's incoming data type -->
            <dataType>String</dataType>
            <!-- 
              The regular expression used to match a data sample.
              Best to keep data pattern on one line below 
            -->
            <dataPattern>\d{2}/\d{2}/\d{4} \d{2}:\d{2}:\d{2}[ ]*[\S]*[ ]*[\S]*[ ]*[\S]*[ ]*[\S]*[ ]*[\S]*[ ]*[\S]*[ ]*[\S]*[ ]*[\S]*[ ]*[\S]*[ ]*[\S]*\s*</dataPattern>
            <!-- 
              The character that delimits variables within the sample
              Use Hex notation for non-printing, whitespace characters (like space)
            -->
            <fieldDelimiter>0x20</fieldDelimiter>
            <!-- 
              The character(s) that delimit records (samples) in a stream or file
              Use Hex notation for non-printing characters, separate characters with a pipe
            -->
            <recordDelimiters>0x0d|0x0A</recordDelimiters>
            <!-- 
              The list of date formats for each sample date component in a separtate variable
              One or more date formats are required, reflecting the date/time variables in the data
              Note: dateFormat and dateField are used together to locate, then parse the sample date
              -->
            <dateFormats>
              <dateFormat>MM/dd/yyyy</dateFormat> 
              <dateFormat>HH:mm:ss</dateFormat>
            </dateFormats>
            <!-- 
              The list of date fields for each sample date component in a separtate variable
              One or more date fields are required, corresponding to the date/time variable positions in the data 
            -->        
            <dateFields>
              <dateField>1</dateField>
              <dateField>2</dateField>
            </dateFields>
            <!-- The time zone identifier that the data were collected in -->
            <timeZone>HST</timeZone>
        </channel>
    </channels>   
</instrument>